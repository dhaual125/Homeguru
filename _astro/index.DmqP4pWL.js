import {
  j as P
} from "./jsx-runtime.D_zvdyIk.js";
import {
  r as s
} from "./index.Ba4_ASc-.js";
import {
  M as A,
  i as z,
  u as S,
  P as D,
  a as K,
  b as U,
  L as B
} from "./proxy.BAVlt-Tv.js";

function I(e, r) {
  if (typeof e == "function") return e(r);
  e != null && (e.current = r)
}

function F(...e) {
  return r => {
    let t = !1;
    const o = e.map(u => {
      const f = I(u, r);
      return !t && typeof f == "function" && (t = !0), f
    });
    if (t) return () => {
      for (let u = 0; u < o.length; u++) {
        const f = o[u];
        typeof f == "function" ? f() : I(e[u], null)
      }
    }
  }
}

function G(...e) {
  return s.useCallback(F(...e), e)
}
class V extends s.Component {
  getSnapshotBeforeUpdate(r) {
    const t = this.props.childRef.current;
    if (t && r.isPresent && !this.props.isPresent) {
      const o = t.offsetParent,
        u = z(o) && o.offsetWidth || 0,
        f = z(o) && o.offsetHeight || 0,
        n = this.props.sizeRef.current;
      n.height = t.offsetHeight || 0, n.width = t.offsetWidth || 0, n.top = t.offsetTop, n.left = t.offsetLeft, n.right = u - n.width - n.left, n.bottom = f - n.height - n.top
    }
    return null
  }
  componentDidUpdate() { }
  render() {
    return this.props.children
  }
}

function X({
  children: e,
  isPresent: r,
  anchorX: t,
  anchorY: o,
  root: u
}) {
  const f = s.useId(),
    n = s.useRef(null),
    g = s.useRef({
      width: 0,
      height: 0,
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    }),
    {
      nonce: R
    } = s.useContext(A),
    w = e.props?.ref ?? e?.ref,
    l = G(n, w);
  return s.useInsertionEffect(() => {
    const {
      width: y,
      height: c,
      top: a,
      left: d,
      right: m,
      bottom: C
    } = g.current;
    if (r || !n.current || !y || !c) return;
    const M = t === "left" ? `left: ${d}` : `right: ${m}`,
      b = o === "bottom" ? `bottom: ${C}` : `top: ${a}`;
    n.current.dataset.motionPopId = f;
    const x = document.createElement("style");
    R && (x.nonce = R);
    const p = u ?? document.head;
    return p.appendChild(x), x.sheet && x.sheet.insertRule(`
          [data-motion-pop-id="${f}"] {
            position: absolute !important;
            width: ${y}px !important;
            height: ${c}px !important;
            ${M}px !important;
            ${b}px !important;
          }
        `), () => {
        p.contains(x) && p.removeChild(x)
      }
  }, [r]), P.jsx(V, {
    isPresent: r,
    childRef: n,
    sizeRef: g,
    children: s.cloneElement(e, {
      ref: l
    })
  })
}
const Y = ({
  children: e,
  initial: r,
  isPresent: t,
  onExitComplete: o,
  custom: u,
  presenceAffectsLayout: f,
  mode: n,
  anchorX: g,
  anchorY: R,
  root: w
}) => {
  const l = S(_),
    y = s.useId();
  let c = !0,
    a = s.useMemo(() => (c = !1, {
      id: y,
      initial: r,
      isPresent: t,
      custom: u,
      onExitComplete: d => {
        l.set(d, !0);
        for (const m of l.values())
          if (!m) return;
        o && o()
      },
      register: d => (l.set(d, !1), () => l.delete(d))
    }), [t, l, o]);
  return f && c && (a = {
    ...a
  }), s.useMemo(() => {
    l.forEach((d, m) => l.set(m, !1))
  }, [t]), s.useEffect(() => {
    !t && !l.size && o && o()
  }, [t]), n === "popLayout" && (e = P.jsx(X, {
    isPresent: t,
    anchorX: g,
    anchorY: R,
    root: w,
    children: e
  })), P.jsx(D.Provider, {
    value: a,
    children: e
  })
};

function _() {
  return new Map
}
const $ = e => e.key || "";

function H(e) {
  const r = [];
  return s.Children.forEach(e, t => {
    s.isValidElement(t) && r.push(t)
  }), r
}
const O = ({
  children: e,
  custom: r,
  initial: t = !0,
  onExitComplete: o,
  presenceAffectsLayout: u = !0,
  mode: f = "sync",
  propagate: n = !1,
  anchorX: g = "left",
  anchorY: R = "top",
  root: w
}) => {
  const [l, y] = K(n), c = s.useMemo(() => H(e), [e]), a = n && !l ? [] : c.map($), d = s.useRef(!0), m = s.useRef(c), C = S(() => new Map), M = s.useRef(new Set), [b, x] = s.useState(c), [p, L] = s.useState(c);
  U(() => {
    d.current = !1, m.current = c;
    for (let h = 0; h < p.length; h++) {
      const i = $(p[h]);
      a.includes(i) ? (C.delete(i), M.current.delete(i)) : C.get(i) !== !0 && C.set(i, !1)
    }
  }, [p, a.length, a.join("-")]);
  const j = [];
  if (c !== b) {
    let h = [...c];
    for (let i = 0; i < p.length; i++) {
      const E = p[i],
        v = $(E);
      a.includes(v) || (h.splice(i, 0, E), j.push(E))
    }
    return f === "wait" && j.length && (h = j), L(H(h)), x(c), null
  }
  const {
    forceRender: T
  } = s.useContext(B);
  return P.jsx(P.Fragment, {
    children: p.map(h => {
      const i = $(h),
        E = n && !l ? !1 : c === p || a.includes(i),
        v = () => {
          if (M.current.has(i)) return;
          if (M.current.add(i), C.has(i)) C.set(i, !0);
          else return;
          let k = !0;
          C.forEach(W => {
            W || (k = !1)
          }), k && (T?.(), L(m.current), n && y?.(), o && o())
        };
      return P.jsx(Y, {
        isPresent: E,
        initial: !d.current || t ? void 0 : !1,
        custom: r,
        presenceAffectsLayout: u,
        mode: f,
        root: w,
        onExitComplete: E ? void 0 : v,
        anchorX: g,
        anchorY: R,
        children: h
      }, i)
    })
  })
};
export {
  O as A, X as P, Y as a, G as u
};